// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_Fitness_Per_Pixel
#pragma kernel CS_Sum_Rows
#pragma kernel CS_Sum_Column


// ----------------------------------------------------------------------------------------------------
// Resources for all the Kernels
RWStructuredBuffer<float>    _per_pixel_fitness_buffer;                                                  // Holds the fitness of each pixel of the attempt
                                                                                                         
RWTexture2D<float4>          _debug_texture;                                                             // you can use this to debug out the content of _per_pixel_fitness_buffer
                                                                                                         
int                          _image_width;                                                               // global image einformation
int                          _image_height;                                                              // global image einformation
int                          _population_id_handel;                                                      // The handel of the population which is currently being rendererd
// ---------------------------------------------------------------------------------------------------   
// Resources for CS_Fitness_Per_Pixel                                                                    
Texture2D<float4>            _original;                                                                  // the original image we want to replicate. The pixels in this image are used to calculated the fitness of each population
Texture2D<float4>            _forged;                                                                    // What coames out of the render pipline, it is the visualisation of the population which gets compared to the original
SamplerState                 sampler_original;
SamplerState                 sampler_forged;

float _hue_weight;
float _sat_weight;
float _val_weight;
// ---------------------------------------------------------------------------------------------------
// Resources for CS_Sum_Rows
RWStructuredBuffer <float>   _rows_sums_array;                                                           // To take the average fitness of a population, we fist sum up each row to a single value and save in this buffer

// ---------------------------------------------------------------------------------------------------
// Resources for CS_Sum_Columns
RWStructuredBuffer <float>   _population_fitness_array;                                                  // this buffer holds one fitness value per population member. The _population_id_handel is used to write to this buffer for each population member


// ===================================================================================================
#define EPSILON  1e-10
// https://www.shadertoy.com/view/4dKcWK
float3 RGBtoHCV(in float3 rgb)
{
    // RGB [0..1] to Hue-Chroma-Value [0..1]
    // Based on work by Sam Hocevar and Emil Persson
    float4 p = (rgb.g < rgb.b) ? float4(rgb.bg, -1., 2. / 3.) : float4(rgb.gb, 0., -1. / 3.);
    float4 q = (rgb.r < p.x) ? float4(p.xyw, rgb.r) : float4(rgb.r, p.yzx);
    float c = q.x - min(q.w, q.y);
    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);
    return float3(h, c, q.x);
}



inline int texture_pixel_to_structured_buffer_ID(uint2 texture_pixel) {
    return _image_width * texture_pixel.y + texture_pixel.x;
}

inline int2 structured_buffer_id_to_texture_pixel(int structured_buffer_id) {
    int y = floor(structured_buffer_id / _image_width);
    int x = fmod(structured_buffer_id, _image_width);
    return int2(x,y);
}


[numthreads(32,32,1)]                                                                                    // image dimensions should be a multiplye of 32 or power of 2. 1024 threads per group
void CS_Fitness_Per_Pixel(uint3 id : SV_DispatchThreadID)                                                
{                                                                                                        

    float2 texutre_coordinates = float2((float)id.x / (float)_image_width,                               
                                        (float)id.y / (float)_image_height);                             


    float3 original_color = _original.SampleLevel(sampler_original, texutre_coordinates, 3).xyz;
           //original_color = RGBtoHCV(original_color);

    float3 forged_color   = _forged.SampleLevel(sampler_forged, texutre_coordinates, 3).xyz;
           //forged_color   = RGBtoHCV(forged_color);

    float3 fittness       = 1. - saturate(abs(original_color - forged_color)) ;

    int structured_buffer_ID = texture_pixel_to_structured_buffer_ID(id.xy);                             
    _per_pixel_fitness_buffer[structured_buffer_ID] = fittness.x *_hue_weight + fittness.y *_sat_weight + fittness.z*_val_weight;

   // int2 texture_pixel = structured_buffer_id_to_texture_pixel(structured_buffer_ID);                  // Debug used to figure out what I have written 
   // _debug_texture[texture_pixel] = _per_pixel_fitness_buffer[structured_buffer_ID];                   // in the structured buffer _per_pixel_fitness. this texture can be blitted to the screen in EvolutionManager.cs for debug porpuses
}



// ----------------------------------------------------------------------------------------------------



[numthreads(64, 1, 1)]                                                                                   // image dimensions should be a multiplye of 64 or power of 2. 64 threads per group
void CS_Sum_Rows(uint3 id : SV_DispatchThreadID)                                                         
{                                                                                                        
                                                                                                         
    int2  texutre_pixel = int2( 0, id.x);                                                                
    float sum           = 0.0f;                                                                          
                                                                                                         
    for (int i = 0; i < _image_width; i++) {                                                             
                texutre_pixel.x      = i;                                                                
        int     structured_buffer_id = texture_pixel_to_structured_buffer_ID(texutre_pixel.xy);
                sum                 += _per_pixel_fitness_buffer[structured_buffer_id];
    }                                                                                                    
    _rows_sums_array[id.x] = sum;                                                                        
}                                                                                                        
                                                                                                         
// ----------------------------------------------------------------------------------------------------  
                                                                                                         
[numthreads(1, 1, 1)]                                                                                    //  only one thread is enough to sum all the columns                                                                   
void CS_Sum_Column(uint3 id : SV_DispatchThreadID)                                                       
{                                                                                                        
    float sum = 0.0f;                                                                                    
    for (int i = 0; i < _image_height; i++) {                                                            
        sum += _rows_sums_array[i];                                                                      
    }                                                                                                    
                    
    _population_fitness_array[_population_id_handel] = sum;                                         

}





