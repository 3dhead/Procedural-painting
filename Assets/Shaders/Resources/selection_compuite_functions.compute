// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CS_transform_fitness_to_probability
#pragma kernel CS_parent_selection
#pragma kernel CS_debug_wang_hash
#pragma kernel CS_cross_over
#pragma kernel CS_mutation_and_copy


#define Tau       6.283185307
#define scale_low 0.1
#define scale_up  3.0

// The below macro is used to get a random number which varies across different generations. The divided by 4 is there to avoid an integer overflow 
// If the seed gets bigger than half of max uint (0xFFFFFFFF) then it would be an issue. This means the total number of threads across all groups 
// in a dispatch shouldnt get bigger than 2,147,483,647 threads. Max thread size in each direction is 65, 535 so just have to make sure all dimensions dont 
// exceed the stated number.

//+ fmod(triple32(_generation_number + 51),0xFFFFFFFF/2)
#define rnd(seed, gen, constant)  wang_rnd(seed +_generation_number  * constant ) 

struct Genes
{
    float2 position;       // screen space 0-1
    float  z_Rotation;     // 0 to tau
    float2 scale;          // scale in quad aligned space, will be clamped
    float3 color;          // the colors of each stroke
    int    texture_ID;     // such a waste of bit space. I only need 2 bits, but paying the cost 8 + padding
};  // Struct size 8 *4 bytes + 1  * 4 = 36 bytes

// ----------------------------------------------------------------------------------------------------
// REsource for all kernels

uint                         _population_pool_size;
uint                         _genes_number_per_member;
RWStructuredBuffer<float>    _population_accumlative_probablities_array;
RWStructuredBuffer<uint2>    _second_gen_parent_ids;                                                  // Buffer has as many members as the population pool size. Each member is made up of an x and a y. The two are parents that produce the next generation

RWStructuredBuffer<Genes>    _second_gen_population_pool;
RWStructuredBuffer<Genes>    _population_pool;

int                          _generation_number;                                                      // this is used to not generate the same random sequence for all generations.
// ----------------------------------------------------------------------------------------------------
// Resource for CS_normalize_population_probabilities

StructuredBuffer <float>     _population_fitness_array;
RWStructuredBuffer<uint>     _fittest_member;                                                         // this structured buffer only has one member. It is a single int. I am sure there is a way to do this with a groupshared global int, and still read it on the CPU, however since I have to figure out how to do that within unity API I will just use a tiny structured buffer with one member
// ----------------------------------------------------------------------------------------------------
// Resource for CS_wang_hash

RWTexture2D<float4>          _debug_texture;                                                          // this is used to test how well random number generation works
int                          _image_width;                                                            // global image einformation. Used for debuging
int                          _image_height;                                                           // global image einformation. Used for debuging

// ----------------------------------------------------------------------------------------------------
// Resource for CS_parent_selection

// ----------------------------------------------------------------------------------------------------
// Resource for CS_mutation_and_copy

float                        _mutation_rate;

// ----------------------------------------------------------------------------------------------------
// -------------------- https://www.shadertoy.com/view/WttXWX

uint triple32(uint x)
{
    x ^= x >> 17;
    x *= 0xed5ad4bbU;
    x ^= x >> 11;
    x *= 0xac4c1b51U;
    x ^= x >> 15;
    x *= 0x31848babU;
    x ^= x >> 14;
    return x;
}

float wang_rnd(uint seed)
{
    uint rndint = triple32(seed);
    return ((float)rndint) / float(0xFFFFFFFF);                                                       // 0xFFFFFFFF is max unsigned integer in hexa decimal
}

inline Genes mutate_gene(uint seed) 
{
    Genes toReturn;

    toReturn.position   = float2(rnd(seed, _generation_number, 51),                                   // Position X. range -1 -> 1
                                 rnd(seed, _generation_number, 712))* 2.0 - 1.0;                      // Position Y. range -1 -> 1

    toReturn.z_Rotation = rnd(seed, _generation_number, 25) * Tau;                                    // 0 to 360 degrees or 2 PI for our functions

    toReturn.scale      = float2(rnd(seed, _generation_number, 82),                                   // Scale X.
                                 rnd(seed, _generation_number, 7)) *                                  // Scale Y.
                                 (scale_up - scale_low) + scale_low;                                  // Remap to lower and higher bound of the scale range

    toReturn.color      = float3(rnd(seed, _generation_number, 62),                                   // brush strokes color channel. R
                                 rnd(seed, _generation_number, 13),                                   // brush strokes color channel. G
                                 rnd(seed, _generation_number, 662));                                 // brush strokes color channel. B  

    toReturn.texture_ID = floor(rnd(seed, _generation_number, 992) * 4);                              // integer id betwen 0 and 3 inclusive 0 and 3. So 4 elements


    return toReturn;
}

// ----------------------------------------------------------------------------------------------------

[numthreads(1,1,1)]                                                                                   // This will run once, a single thread
void CS_transform_fitness_to_probability(uint3 id : SV_DispatchThreadID)
{
    
    float total_sum    = 0.0;
    float temp         = 0.0;
    
    float highest_fitness  = 0.0f;
    uint  m_fittest_member = 20000;
    for (uint i = 0; i < _population_pool_size; i++) {

        if(_population_fitness_array[i]> highest_fitness)                                              // this finds out which member has the highest fitness. This is used for visualisation at the end of the render loop, the fittest member is redrawn-
        {
            highest_fitness  = _population_fitness_array[i];
            m_fittest_member = i;
        }

        total_sum  += _population_fitness_array[i];
        _population_accumlative_probablities_array[i] = total_sum;                                     // since I am using only one thread, I dont have to worry about writing to the same cacheline I am reading from and false sharing. 
    }

    _fittest_member[0] = m_fittest_member;

    temp = 0.0;
    for (uint j = 0; j < _population_pool_size; j++) {
        temp = _population_accumlative_probablities_array[j];
        _population_accumlative_probablities_array[j] = temp / total_sum;                              // actual normalization happens here. Now the fitness of each member is converted to a probablity of the member being selection, with regards to how fit the other members are
    } 


}

// ----------------------------------------------------------------------------------------------------

[numthreads(32,1,1)]                                                                                  // 1 threads per population pool member. change to whatever works for you
void CS_parent_selection(uint3 id : SV_DispatchThreadID)
{
    
    float randomNumber = rnd(id.x, _generation_number, 25);
    uint i = 0;
    for (     ; i < _population_pool_size; i++){
        if(randomNumber <= _population_accumlative_probablities_array[i]) break;
    }

    randomNumber = rnd(id.x, _generation_number, 61);
    uint j = 0;
    for (     ; j < _population_pool_size; j++){
        if(randomNumber <= _population_accumlative_probablities_array[j]) break;
    }
 
    _second_gen_parent_ids[id.x] = uint2(i, j);
}

[numthreads(8, 8, 1)]                                                                         
void CS_debug_wang_hash(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(_image_width * id.y + id.x, _generation_number, 13);
 
    // used to see if the rand is normalized correctly between 0 and 1
    //if (rand < 0 || rand>1) rand = 1;
    //else rand = 0;
    _debug_texture[id.xy] = float4(rand, rand, rand, 1.0);
}


// ----------------------------------------------------------------------------------------------------

[numthreads(128,1,1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_cross_over(uint3 id : SV_DispatchThreadID)
{
    
    uint  population_id      = floor(id.x / _genes_number_per_member);                                // Since this is a thread per gene, if there are 5 population members with 10 genes each there will be 50 threads. This number indicates which of those for example 5 population member this thread belongs to
    uint  popluation_gene_id = fmod (id.x,  _genes_number_per_member);                                // If the above number is for example is 4, then this thread is dealing with one of the genes of the 4th member. This number indicates which of those 10 genes of the 4 member for example it is. In this example, number 12 would be dealing with the 2 gene of the 3 member if you start counting from one (array count from zero)

    uint2 parents            = _second_gen_parent_ids[population_id];                                 // Look at the _second_gen_parent_ids declerantion for more info on what those two values are

    uint  parentToTakeFrom   = parents.y;

    if (popluation_gene_id < _genes_number_per_member / 2) parentToTakeFrom = parents.x;              // very simple cross over algo. take the first half of the genes from one parent and the second half from the other. 

    _second_gen_population_pool[id.x] =                                                               // Each thread is mapped to a gene of the second generation, so we can easily use id.x to write that gene
        _population_pool[parentToTakeFrom * _genes_number_per_member + popluation_gene_id];           // example: If we want to take 5th gene of the parent.x which is for example population member 3, we would have to first jump to where population 3 starts which is 3 members that consist of ex. 10 genes so we start at 30 and add the 5 which is the gene we want to coppy 
}


[numthreads(128,1,1)]                                                                                  // 1 threads per gene member. change to whatever works for you
void CS_mutation_and_copy(uint3 id : SV_DispatchThreadID)
{
    float rand = rnd(id.x, _generation_number, 45);

    

    if (rand <= _mutation_rate) _population_pool[id.x] = mutate_gene(id.x);
    else _population_pool[id.x] = _second_gen_population_pool[id.x];

}
